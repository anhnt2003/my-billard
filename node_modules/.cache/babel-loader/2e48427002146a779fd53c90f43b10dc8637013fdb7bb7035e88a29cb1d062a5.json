{"ast":null,"code":"var _GameService;\nconst STORAGE_KEY = 'billard_game_data';\nclass GameService {\n  constructor() {\n    this.gameData = {\n      players: [],\n      rounds: [],\n      lastUpdate: new Date().toISOString()\n    };\n    this.loadFromStorage();\n  }\n  static getInstance() {\n    if (!GameService.instance) {\n      GameService.instance = new GameService();\n    }\n    return GameService.instance;\n  }\n  loadFromStorage() {\n    const storedData = localStorage.getItem(STORAGE_KEY);\n    if (storedData) {\n      try {\n        this.gameData = JSON.parse(storedData);\n      } catch (error) {\n        console.error('Error parsing stored game data:', error);\n      }\n    }\n  }\n  saveToStorage() {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(this.gameData));\n    } catch (error) {\n      console.error('Error saving game data:', error);\n    }\n  }\n  async loadGameData() {\n    return this.gameData;\n  }\n  async saveGameData(players, rounds) {\n    try {\n      this.gameData = {\n        players,\n        rounds,\n        lastUpdate: new Date().toISOString()\n      };\n      this.saveToStorage();\n      return true;\n    } catch (error) {\n      console.error('Error saving game data:', error);\n      return false;\n    }\n  }\n  async updateRound(round) {\n    try {\n      const roundIndex = this.gameData.rounds.findIndex(r => r.roundNumber === round.roundNumber);\n      if (roundIndex >= 0) {\n        this.gameData.rounds[roundIndex] = round;\n      } else {\n        this.gameData.rounds.push(round);\n      }\n\n      // Update players' scores\n      round.scores.forEach(score => {\n        const player = this.gameData.players.find(p => p.id === score.playerId);\n        if (player) {\n          player.totalScore = score.totalScore;\n        }\n      });\n      this.gameData.lastUpdate = new Date().toISOString();\n      this.saveToStorage();\n      return true;\n    } catch (error) {\n      console.error('Error updating round:', error);\n      return false;\n    }\n  }\n}\n_GameService = GameService;\nGameService.instance = void 0;\nexport const gameService = GameService.getInstance();","map":{"version":3,"names":["STORAGE_KEY","GameService","constructor","gameData","players","rounds","lastUpdate","Date","toISOString","loadFromStorage","getInstance","instance","storedData","localStorage","getItem","JSON","parse","error","console","saveToStorage","setItem","stringify","loadGameData","saveGameData","updateRound","round","roundIndex","findIndex","r","roundNumber","push","scores","forEach","score","player","find","p","id","playerId","totalScore","_GameService","gameService"],"sources":["/Users/mac/work space /my-billard/src/services/gameService.ts"],"sourcesContent":["import {\n  GameData,\n  Player,\n  RoundHistory,\n} from '../types/gameTypes';\n\nconst STORAGE_KEY = 'billard_game_data';\n\nclass GameService {\n  private static instance: GameService;\n  private gameData: GameData = {\n    players: [],\n    rounds: [],\n    lastUpdate: new Date().toISOString()\n  };\n\n  private constructor() {\n    this.loadFromStorage();\n  }\n\n  public static getInstance(): GameService {\n    if (!GameService.instance) {\n      GameService.instance = new GameService();\n    }\n    return GameService.instance;\n  }\n\n  private loadFromStorage(): void {\n    const storedData = localStorage.getItem(STORAGE_KEY);\n    if (storedData) {\n      try {\n        this.gameData = JSON.parse(storedData);\n      } catch (error) {\n        console.error('Error parsing stored game data:', error);\n      }\n    }\n  }\n\n  private saveToStorage(): void {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(this.gameData));\n    } catch (error) {\n      console.error('Error saving game data:', error);\n    }\n  }\n\n  public async loadGameData(): Promise<GameData> {\n    return this.gameData;\n  }\n\n  public async saveGameData(players: Player[], rounds: RoundHistory[]): Promise<boolean> {\n    try {\n      this.gameData = {\n        players,\n        rounds,\n        lastUpdate: new Date().toISOString()\n      };\n      this.saveToStorage();\n      return true;\n    } catch (error) {\n      console.error('Error saving game data:', error);\n      return false;\n    }\n  }\n\n  public async updateRound(round: RoundHistory): Promise<boolean> {\n    try {\n      const roundIndex = this.gameData.rounds.findIndex(r => r.roundNumber === round.roundNumber);\n      if (roundIndex >= 0) {\n        this.gameData.rounds[roundIndex] = round;\n      } else {\n        this.gameData.rounds.push(round);\n      }\n\n      // Update players' scores\n      round.scores.forEach(score => {\n        const player = this.gameData.players.find(p => p.id === score.playerId);\n        if (player) {\n          player.totalScore = score.totalScore;\n        }\n      });\n\n      this.gameData.lastUpdate = new Date().toISOString();\n      this.saveToStorage();\n      return true;\n    } catch (error) {\n      console.error('Error updating round:', error);\n      return false;\n    }\n  }\n}\n\nexport const gameService = GameService.getInstance(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}